# my_shell
My shell, wriiten on C as one of my 3sem projects in CMC

Задание практикума No 6. Командный интерпретатор.  
 
Необходимо реализовать под управлением ОС Unix интерактивный командный  
интерпретатор (некоторый аналог shell), осуществляющий в цикле считывание командной 
строки со стандартного ввода, ее анализ и исполнение соответствующих действий.   
В командной строке могут присутствовать следующие операции: 
указаны в порядке убывания приоритетов (на одной строке приоритет одинаков) 
 |  ,  > , >> , < 
&& , || 
; , & 
Допустимы также круглые скобки, которые  позволяют изменить порядок выполнения 
операций. Для выполнения команды в скобках создаётся отдельный экземпляр Shellа. 
В командной строке допустимо также произвольное количество пробелов между 
составляющими ее словами. 
 
Разбор командной строки  осуществляется Shelloм по следующим правилам: 
 
<Команда Shellа > → 
 < Команда с условным выполнением >{ [; | &] < Команда Shellа>}{ ; |&} 
       
<Команда с условным выполнением > → 
 <Команда> { [&& |  || ] <Команда с условным выполнением>} 
<Команда> → {<перенаправление ввода/вывода>}<Конвейер>  | 
       <Конвейер>{<перенаправление ввода/вывода>} | ( <Команда Shellа>) 
<перенаправление ввода/вывода> → 
{<перенаправление ввода > } <перенаправление вывода> | 
{<перенаправление вывода>}<перенаправление ввода > 
<перенаправление ввода > →    ‘<’ файл 
<перенаправление вывода> →  ‘>’ файл |  ‘>>’ файл 
<Конвейер>→ <Простая команда> {‘|’ <Конвейер>} 
<Простая команда>→ <имя команды><список аргументов> 
 
{X} – означает, что X может отсутствовать; 
[x|y] – значит, что должен присутствовать один из вариантов : x либо y 
|  - в описании правил то же, что «ИЛИ» 
 
pr1 | ...| prN – конвейер: стандартный вывод всех команд, кроме последней, направляется 
на стандартный ввод следующей команды конвейера. Каждая команда выполняется как 
самостоятельный процесс (т.е. все pri  выполняются параллельно). Shell ожидает 
завершения последней команды.  
 Код завершения конвейера = код завершения последней команды конвейера. 
Простую команду можно  рассматривать как частный случай конвейера. 
 
com1 ; com2 – означает, что команды будут выполняться последовательно 
 
com & - запуск команды в фоновом режиме (т.е. Shell готов к вводу следующей команды, 
не ожидая завершения  данной команды com, а com  не реагирует на сигналы завершения, 
посылаемые с клавиатуры, например, на нажатие Ctrl-C ). После завершения выполнения 
фоновой команды не должно остаться процесса – зомби. Посмотреть список работающих 
процессов можно с помощью команды ps. 
 
com1 && com2 -  выполнить com1, если она завершилась успешно, выполнить com2; 
com1 || com2 -  выполнить com1, если она завершилась неуспешно, выполнить com2. 
Должен быть проверен и системный успех и значение, возвращенное exit ( 0 – успех). 
 
Перенаправление ввода-вывода : 
< файл -  файл используется в качестве стандартного ввода; 
> файл -  стандартный  вывод направляется в файл (если файла не было - он создается, 
если файл уже существовал, то его старое содержимое отбрасывается, т.е. происходит 
вывод с перезаписью); 
>> файл – стандартный  вывод направляется в файл ( если файла не было - он создается, 
если файл уже существовал, то его старое содержимое сохраняется, а запись производится  
в конец файла) 
